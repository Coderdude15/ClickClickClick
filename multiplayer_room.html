<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multiplayer Duel</title>
</head>
<body>
  <h1 id="modeTitle">🌐 Multiplayer Duel</h1>

  <!-- Rank Badges -->
  <div id="playerRankBadge" class="rankBadge left">🏅 Unranked</div>
  <div id="opponentRankBadge" class="rankBadge right">🏅 Waiting...</div>

  <p id="status">Connecting...</p>

  <!-- Duel layout -->
  <div id="duelContainer">
    <div id="playerSide" class="scorePanel">
      <h2 id="yourName">You</h2>
      <p>Score: <span id="playerScore">0</span></p>
    </div>
    <div id="vsText">VS</div>
    <div id="opponentSide" class="scorePanel">
      <h2 id="opponentName">Waiting...</h2>
      <p>Score: <span id="opponentScore">0</span></p>
    </div>
  </div>

  <!-- Buttons -->
  <div class="buttons">
    <button id="AddBtn">Add</button>
    <button id="XBtn" style="display:none;">Multiply ✖️</button>
    <div id="multiplyTimer" style="margin-top:15px;font-size:20px;font-weight:bold;">Multiply in: calculating...</div>
  </div>

  <button id="LeaveBtn">⬅️ Leave</button>

  <!-- Rank Animation Overlay -->
  <div id="rankAnimation" class="hidden">
    <div id="rankAnimText"></div>
  </div>

  <!-- Sounds -->
  <audio id="multiplySound" src="ding-36029.mp3" preload="auto"></audio>
  <audio id="rankUpSound" src="rank-up.mp3" preload="auto"></audio>
  <audio id="rankDownSound" src="rank-down.mp3" preload="auto"></audio>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>

  <script>
  // ---------- FIREBASE CONFIG ----------
  const firebaseConfig = {
    apiKey: "AIzaSyC0lC1S6unGubGU6fQcgvd0qnOYz_pGa_Q",
    authDomain: "leaderboard-65f6e.firebaseapp.com",
    databaseURL: "https://leaderboard-65f6e-default-rtdb.firebaseio.com",
    projectId: "leaderboard-65f6e",
    storageBucket: "leaderboard-65f6e.firebasestorage.appspot.com",
    messagingSenderId: "515120673437",
    appId: "1:515120673437:web:63e2df3edc463bdfdd9a74"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ---------- VARIABLES ----------
  const mode = localStorage.getItem("multiplayerMode") || "casual";
  let playerName = prompt("Enter your username:") || "Guest" + Math.floor(Math.random() * 1000);
  let uid = null;
  let roomRef = null;
  let playerScore = 0;
  let opponentName = "";
  let opponentScore = 0;
  let opponentJoined = false;
  let matchEnded = false;

  const AddBtn = document.getElementById("AddBtn");
  const XBtn = document.getElementById("XBtn");
  const LeaveBtn = document.getElementById("LeaveBtn");
  const multiplyTimer = document.getElementById("multiplyTimer");
  const multiplySound = document.getElementById("multiplySound");

  document.getElementById("modeTitle").textContent = mode === "ranked" ? "🔥 Ranked Duel" : "😎 Casual Duel";

  // ---------- BUTTON HANDLERS ----------
  AddBtn.onclick = () => {
    playerScore++;
    updateScore();
  };

  XBtn.onclick = () => {
    playerScore = Math.floor(playerScore * 1.2);
    updateScore();
  };

  LeaveBtn.onclick = () => {
    if (mode === "ranked" && opponentJoined && !matchEnded) {
      alert("You cannot leave during a ranked match!");
      return;
    }
    leaveRoom();
  };

  function updateScore() {
    if (!roomRef || matchEnded) return;
    roomRef.once("value").then(snap => {
      const data = snap.val();
      if (!data) return;
      if (data.player1 && data.player1.uid === uid)
        roomRef.child("player1/score").set(playerScore);
      else if (data.player2 && data.player2.uid === uid)
        roomRef.child("player2/score").set(playerScore);
    });
  }


  // ---------- MULTIPLY LOGIC ----------
  function getRandomSeconds(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function formatTime(ms) {
    const sec = Math.ceil(ms / 1000);
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m > 0 ? m + "m " : ""}${s}s`;
  }

  function scheduleMultiplyButton() {
    const delaySec = getRandomSeconds(30, 60);
    let remaining = delaySec * 1000;
    const countdown = setInterval(() => {
      if (remaining <= 0) clearInterval(countdown);
      else {
        multiplyTimer.textContent = `Multiply in: ${formatTime(remaining)}`;
        remaining -= 1000;
      }
    }, 1000);

    setTimeout(() => {
      XBtn.style.display = "inline-block";
      multiplySound.play().catch(()=>{});
      multiplyTimer.textContent = "Multiply available!";
      clearInterval(countdown);
      const visibleDuration = getRandomSeconds(2, 5) * 1000;
      setTimeout(() => {
        XBtn.style.display = "none";
        scheduleMultiplyButton();
      }, visibleDuration);
    }, delaySec * 1000);
  }
  scheduleMultiplyButton();

  // ---------- ROOM + MATCH LOGIC ----------
  firebase.auth().signInAnonymously().then((userCredential) => {
    uid = userCredential.user.uid;
    console.log("Signed in anonymously ✅", uid);

    // Rank setup + seasonal reset
    checkSeasonReset();
    const rankRef = db.ref(`ranks/${uid}`);
    rankRef.once("value").then(snap => {
      if (!snap.exists()) {
        rankRef.set({ name: playerName, rankPoints: 0, rank: "Unranked", totalScore: 0 });
      }
      updateRankBadge();
    });

    const lobbyRef = db.ref(`multiplayer/${mode}/lobby`);

    lobbyRef.once("value").then(snapshot => {
      const lobbyPlayers = snapshot.val() || {};
      const available = Object.keys(lobbyPlayers).filter(id => id !== uid);

      if (available.length === 0) {
        const roomId = "room_" + Math.floor(Math.random() * 100000);
        roomRef = db.ref(`multiplayer/${mode}/rooms/${roomId}`);
        roomRef.set({ player1: { uid, name: playerName, score: 0 } });
        lobbyRef.child(uid).set({ name: playerName, roomId });
        roomRef.onDisconnect().remove();
        lobbyRef.child(uid).onDisconnect().remove();
        document.getElementById("status").textContent = "Waiting for opponent...";
      } else {
        const oppUid = available[0];
        const oppRoomId = lobbyPlayers[oppUid].roomId;
        roomRef = db.ref(`multiplayer/${mode}/rooms/${oppRoomId}`);
        roomRef.update({ player2: { uid, name: playerName, score: 0 } });
        lobbyRef.child(oppUid).remove();
        document.getElementById("status").textContent = "Opponent found!";
      }

      roomRef.on("value", snap => {
        const data = snap.val();
        if (!data) return;

        const p1 = data.player1 || {};
        const p2 = data.player2 || {};

        if (p1.uid === uid) {
          opponentName = p2.name || "Waiting...";
          opponentScore = p2.score || 0;
          playerScore = p1.score || 0;
        } else {
          opponentName = p1.name || "Waiting...";
          opponentScore = p1.score || 0;
          playerScore = p2.score || 0;
        }

        document.getElementById("yourName").textContent = playerName;
        document.getElementById("playerScore").textContent = playerScore;
        document.getElementById("opponentName").textContent = opponentName;
        document.getElementById("opponentScore").textContent = opponentScore;

        if (opponentName !== "Waiting...") {
          document.getElementById("status").textContent = "Match Live!";
          opponentJoined = true;
          updateOpponentRank();
        }

        if (mode === "ranked" && playerScore >= 100000) {
          handleMatchEnd(true);
        }
      });
    });
  });

  // ---------- RANK SYSTEM ----------
  function getRankFromPoints(points) {
    if (points < 30000) return "Bronze I";
    if (points < 70000) return "Bronze II";
    if (points < 120000) return "Bronze III";
    if (points < 180000) return "Silver I";
    if (points < 230000) return "Silver II";
    if (points < 300000) return "Silver III";
    if (points < 550000) return "Gold I";
    if (points < 620000) return "Gold II";
    if (points < 720000) return "Gold III";
    if (points < 850000) return "Platinum I";
    if (points < 1000000) return "Platinum II";
    if (points < 1300000) return "Platinum III";
    if (points < 1800000) return "Diamond I";
    if (points < 2100000) return "Diamond II";
    if (points < 2500000) return "Diamond III";
    if (points < 3500000) return "Elite";
    if (points < 8000000) return "Sentinel";
    return "Iridescent";
  }

  // ---------- MATCH END ----------
  async function handleMatchEnd(won) {
    matchEnded = true;
    const rankRef = db.ref(`ranks/${uid}`);
    const snap = await rankRef.once("value");
    let data = snap.val() || { rankPoints: 0, rank: "Unranked", totalScore: 0 };

    const diff = Math.abs(playerScore - opponentScore);
    const baseGain = Math.min(150, Math.max(25, diff / 4));
    let delta = won ? baseGain : -(baseGain / 1.5);

    const oldRank = data.rank;

    // ✅ Iridescent protection — can’t lose points or derank
    if (oldRank === "Iridescent") delta = Math.max(delta, 0);

    data.rankPoints = Math.max(0, data.rankPoints + delta);
    data.totalScore = (data.totalScore || 0) + playerScore;
    data.rank = getRankFromPoints(data.rankPoints);

    // ✅ Prevent deranking from Iridescent
    if (oldRank === "Iridescent") data.rank = "Iridescent";

    await rankRef.update(data);

    // ✅ Update Iridescent leaderboard numbers
    if (data.rank === "Iridescent") updateIridescentRanks();

    showRankAnimation(oldRank, data.rank, delta);
    setTimeout(() => leaveRoom(), 5000);
  }

  // ---------- UPDATE IRIDESCENT LEADERBOARD ----------
  async function updateIridescentRanks() {
    const snap = await db.ref("ranks").once("value");
    const ranks = snap.val() || {};
    const iridescentPlayers = Object.entries(ranks)
      .filter(([id, d]) => d.rank === "Iridescent")
      .sort((a, b) => (b[1].rankPoints + b[1].totalScore) - (a[1].rankPoints + a[1].totalScore));

    iridescentPlayers.forEach(([id, d], index) => {
      db.ref(`ranks/${id}`).update({ iridescentRank: index + 1 });
    });

    // Update local display for player
    const yourData = iridescentPlayers.find(([id]) => id === uid);
    if (yourData) {
      const rankNum = yourData[1].iridescentRank;
      document.getElementById("playerRankBadge").textContent = `🌈 Iridescent Rank #${rankNum}`;
    }
  }

  // ---------- SEASON RESET EVERY 2 MONTHS ----------
  async function checkSeasonReset() {
    const seasonRef = db.ref("seasonInfo");
    const snap = await seasonRef.once("value");
    const data = snap.val() || {};
    const now = Date.now();
    const twoMonths = 1000 * 60 * 60 * 24 * 60;

    if (!data.lastReset || now - data.lastReset > twoMonths) {
      // Reset all ranks
      const ranksSnap = await db.ref("ranks").once("value");
      const ranks = ranksSnap.val() || {};
      for (const id in ranks) {
        db.ref(`ranks/${id}`).update({
          rank: "Unranked",
          rankPoints: 0,
          iridescentRank: null,
        });
      }
      seasonRef.set({ lastReset: now });
      console.log("🎯 Rank season reset complete!");
    }
  }

  // ---------- UPDATE RANK BADGES ----------
  function updateRankBadge() {
    const badge = document.getElementById("playerRankBadge");
    db.ref(`ranks/${uid}`).on("value", snap => {
      const data = snap.val();
      if (data?.rank === "Iridescent" && data.iridescentRank)
        badge.textContent = `🌈 Iridescent Rank #${data.iridescentRank}`;
      else
        badge.textContent = `🏅 ${data?.rank || "Unranked"}`;
    });
  }

  function updateOpponentRank() {
    const badge = document.getElementById("opponentRankBadge");
    if (!opponentName || opponentName === "Waiting...") {
      badge.textContent = "🏅 Waiting...";
      return;
    }
    db.ref(`ranks`).once("value").then(snap => {
      const ranks = snap.val() || {};
      let found = Object.values(ranks).find(r => r.name === opponentName);
      if (found?.rank === "Iridescent" && found.iridescentRank)
        badge.textContent = `🌈 Iridescent Rank #${found.iridescentRank}`;
      else
        badge.textContent = `🏅 ${found?.rank || "Unranked"}`;
    });
  }

  // ---------- ANIMATION ----------
  function showRankAnimation(oldRank, newRank, delta) {
    const anim = document.getElementById("rankAnimation");
    const text = document.getElementById("rankAnimText");
    const gained = delta > 0;
    const color = gained ? "lime" : "red";
    const symbol = gained ? "⬆️" : "⬇️";
    const action = gained ? "RANK UP!" : "RANK DOWN...";
    const sound = document.getElementById(gained ? "rankUpSound" : "rankDownSound");
    sound.play().catch(() => {});

    text.innerHTML = `
      <div style="animation: pulse 1s infinite; color:${color};">
        ${symbol} <b>${action}</b><br>
        <small>${oldRank}</small> → <b>${newRank}</b>
      </div>
    `;
    anim.classList.remove("hidden");
    anim.style.opacity = 1;
    setTimeout(() => anim.classList.add("hidden"), 4000);
  }

  // ---------- LEAVE ROOM ----------
  function leaveRoom() {
    if (roomRef) roomRef.off();
    db.ref(`multiplayer/${mode}/lobby/${uid}`).remove();
    LeaveBtn.disabled = true;
    document.getElementById("status").textContent = "You left the room.";
    setTimeout(() => (window.location.href = "index.html"), 1000);
  }
  </script>

  <style>
    body { font-family: sans-serif; text-align:center; color:aqua;
      background-image:url("https://cdn.wallpapersafari.com/56/21/bLkiQv.jpg");
      background-size:cover; background-repeat:no-repeat; background-position:center; background-attachment:fixed; }
    .buttons { margin:20px; }
    #duelContainer { display:flex; justify-content:center; margin:20px; align-items:center; }
    .scorePanel { margin:0 20px; width:40%; border:2px solid aqua; padding:20px; border-radius:10px; background:rgba(0,0,0,0.6); }
    #vsText { font-size:2.5rem; font-weight:bold; color:gold; }
    .rankBadge { font-size:16px; margin:10px; display:inline-block; }
    .rankBadge.left { float:left; }
    .rankBadge.right { float:right; }
    #AddBtn, #XBtn { background:aqua; color:black; padding:15px 30px; border:none; border-radius:10px; cursor:pointer; margin:10px; font-size:1.5rem; }
    #LeaveBtn { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:#00ffff; color:black; border:none; border-radius:10px; padding:10px 20px; font-size:1.2rem; cursor:pointer; }
    #rankAnimation { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.8); color:white; padding:30px 50px; border-radius:15px; font-size:2rem; font-weight:bold; z-index:9999; transition:opacity 1s ease; }
    .hidden { display:none; }
    @keyframes pulse { 0%{transform:scale(1);} 50%{transform:scale(1.1);} 100%{transform:scale(1);} }
  </style>
</body>
</html>
